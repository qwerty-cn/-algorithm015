学习笔记 week2

哈希表：（散列表 - C++ STL中包括了map和set，map是key-value，set是key即是value）
=>对于set，包括了unordered_set(value无序不可重复)、unordered_multiset（value无序可重复）、set（value有序不可重复）和multiset（value有序可重复）
=>对于map，包括了unordered_map（key无序不可重复）、unordered_multimap（key无序可重复）、map（key有序不可重复）、multimap（key无序不可重复）
=>特点：search时间复杂度为O(1)、会出现哈希碰撞的问题（常用拉链式解决冲突法）

树、二叉树、二叉搜索树：
=>根节点和叶节点、关系包括了父节点和子节点。当每个父节点只有2个子节点时叫二叉树。所有父节点均有全部的两个子节点叫满二叉树。根据层序遍历没有缺漏的二叉树叫完全二叉树。所有父节点其值小于右节点而大于左=>节点的叫二叉搜索树（BST）
=>遍历方式：前序、中序、后序（DFS）；层序（BFS） - 模板要背下来
=>二叉搜索树:search和insert的时间复杂度为O(logn)


堆与二叉堆：完全二叉树实现堆，数组来实现二叉堆（层序遍历）
=>堆的特性：父节点值一定大于子节点值。
=>常见堆种类：二叉堆，斐波那契堆。
=>二叉堆查询最值：时间复杂度 – O(1)
=>二叉堆的插入操作：
=>1.新值插入至数组末尾 2.从新值开始，依次比较新值与其父节点的大小，并根据大小关系进行交换，直到小于父节点值为止。
时间复杂度：O(logn)
=>二叉堆的删除操作：
1.用数组中最后一个值替换根节点 2.从替换过的新根节点值开始，依次比较新根节点值与其两个子节点之间的大小关系，找较大者进行替换，直到大于左右子节点值为止。
时间复杂度：O(logn)
=>注：1.插入与删除操作得益于二叉树的层序遍历性质：第i个节点的左子节点序号为2i+1，右子节点序号为2(i+1)。同理，第i个节点的父节点为(i-1)/2（i > 0）
一般地，工程代码中选择使用优先队列而非二叉堆。

图：点和边 - 表示方式：邻接矩阵和邻接表
点之间：连同与否？出度还是入度？
边：方向？权重？
=>遍历方式：BFS和DFS
=>相关高级算法：最小生成树、拓扑排序、连接图个数、最短路径。
=>做题时候的积累：BFS一般通过队列来实现，DFS一般通过栈来实现（递归）
